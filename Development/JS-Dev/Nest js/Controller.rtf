NestJS heavily relies on decorators to define the structure and behavior of your application.
Here are some of the most crucial ones:   

Core Decorators -
@Controller(): Defines a controller class, responsible for handling incoming requests.   
@Injectable(): Marks a class as injectable, allowing dependency injection.   
@Module(): Defines a module, encapsulating related components and providers.   
@Service(): Marks a class as a service, providing business logic.
@UseGuards(): Applies guards to protect routes.   
@UsePipes(): Applies pipes to transform and validate incoming data.   
@UseInterceptors(): Applies interceptors to intercept requests and responses.   

Request Handling Decorators - 
@Get(): Defines a route for HTTP GET requests.   
@Post(): Defines a route for HTTP POST requests.
@Put(): Defines a route for HTTP PUT requests.   
@Delete(): Defines a route for HTTP DELETE requests.   
@Patch(): Defines a route for HTTP PATCH requests.   
@Param(): Extracts parameters from the URL.
@Body(): Extracts the request body.
@Query(): Extracts query parameters from the URL.   
@Headers(): Extracts request headers.   
@Req(): Injects the Express request object (use with caution).   
@Res(): Injects the Express response object (use with caution).

Dependency Injection Decorators - 
@Inject(): Inject dependencies into a class.

Other Useful Decorators - 
@HttpCode(): Sets the HTTP status code for a response.   
@HttpStatus(): Accesses HTTP status codes.
@SetMetadata(): Attaches metadata to a class, method, or property.
@ReflectMetadata(): Retrieves metadata from a class, method, or property.

Custom Decorators - 
You can create custom decorators to encapsulate common logic or add custom behavior to your application.
This is a powerful feature for extending NestJS' capabilities.   

